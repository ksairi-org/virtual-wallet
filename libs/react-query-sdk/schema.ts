/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * PostgREST API
 * This is a dynamic API generated by PostgREST
 * OpenAPI spec version: 13.0.4
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type { DataTag, DefinedInitialDataOptions, DefinedUseQueryResult, MutationFunction, QueryClient, QueryFunction, QueryKey, UndefinedInitialDataOptions, UseMutationOptions, UseMutationResult, UseQueryOptions, UseQueryResult } from '@tanstack/react-query';
import { customAxios } from './custom-axios';
export interface Wallet {
    /** Note:
  This is a Primary Key.<pk/> */
    wallet_id: number;
    balance: number;
    created_at?: string;
    updated_at?: string;
    /** Note:
  This is a Foreign Key to `currency.currency_id`.<fk table='currency' column='currency_id'/> */
    currency_id: number;
    user_id: string;
}
export interface User {
    /** @maxLength 255 */
    photo_url?: string;
    /** Note:
  This is a Primary Key.<pk/> */
    user_id: string;
}
export interface Transaction {
    /** Note:
  This is a Primary Key.<pk/> */
    transaction_id: number;
    wallet_id: number;
    /** Note:
  This is a Foreign Key to `transactionType.transaction_type_id`.<fk table='transactionType' column='transaction_type_id'/> */
    transaction_type_id: number;
    amount: number;
    transaction_date?: string;
    description?: string;
}
export interface Currency {
    /** Note:
  This is a Primary Key.<pk/> */
    currency_id: number;
    /** @maxLength 10 */
    name: string;
}
export interface TransactionType {
    /** Note:
  This is a Primary Key.<pk/> */
    transaction_type_id: number;
    /** @maxLength 50 */
    name: string;
}
/**
 * wallet
 */
export type WalletBody = Wallet;
/**
 * user
 */
export type UserBody = User;
/**
 * transaction
 */
export type TransactionBody = Transaction;
/**
 * currency
 */
export type CurrencyBody = Currency;
/**
 * transactionType
 */
export type TransactionTypeBody = TransactionType;
export type PreferParamsParameter = typeof PreferParamsParameter[keyof typeof PreferParamsParameter];
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferParamsParameter = {} as const;
export type PreferReturnParameter = typeof PreferReturnParameter[keyof typeof PreferReturnParameter];
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferReturnParameter = {
    'return=representation': 'return=representation',
    'return=minimal': 'return=minimal',
    'return=none': 'return=none',
} as const;
export type PreferCountParameter = typeof PreferCountParameter[keyof typeof PreferCountParameter];
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferCountParameter = {
    'count=none': 'count=none',
} as const;
export type PreferPostParameter = typeof PreferPostParameter[keyof typeof PreferPostParameter];
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferPostParameter = {
    'return=representation': 'return=representation',
    'return=minimal': 'return=minimal',
    'return=none': 'return=none',
    'resolution=ignore-duplicates': 'resolution=ignore-duplicates',
    'resolution=merge-duplicates': 'resolution=merge-duplicates',
} as const;
/**
 * Filtering Columns
 */
export type SelectParameter = string;
/**
 * On Conflict
 */
export type OnConflictParameter = string;
/**
 * Ordering
 */
export type OrderParameter = string;
/**
 * Limiting and Pagination
 */
export type RangeParameter = string;
/**
 * Limiting and Pagination
 */
export type RangeUnitParameter = string;
/**
 * Limiting and Pagination
 */
export type OffsetParameter = string;
/**
 * Limiting and Pagination
 */
export type LimitParameter = string;
export type RowFilterWalletWalletIdParameter = string;
export type RowFilterWalletBalanceParameter = string;
export type RowFilterWalletCreatedAtParameter = string;
export type RowFilterWalletUpdatedAtParameter = string;
export type RowFilterWalletCurrencyIdParameter = string;
export type RowFilterWalletUserIdParameter = string;
export type RowFilterUserPhotoUrlParameter = string;
export type RowFilterUserUserIdParameter = string;
export type RowFilterTransactionTransactionIdParameter = string;
export type RowFilterTransactionWalletIdParameter = string;
export type RowFilterTransactionTransactionTypeIdParameter = string;
export type RowFilterTransactionAmountParameter = string;
export type RowFilterTransactionTransactionDateParameter = string;
export type RowFilterTransactionDescriptionParameter = string;
export type RowFilterCurrencyCurrencyIdParameter = string;
export type RowFilterCurrencyNameParameter = string;
export type RowFilterTransactionTypeTransactionTypeIdParameter = string;
export type RowFilterTransactionTypeNameParameter = string;
export type GetWalletParams = {
    wallet_id?: RowFilterWalletWalletIdParameter;
    balance?: RowFilterWalletBalanceParameter;
    created_at?: RowFilterWalletCreatedAtParameter;
    updated_at?: RowFilterWalletUpdatedAtParameter;
    currency_id?: RowFilterWalletCurrencyIdParameter;
    user_id?: RowFilterWalletUserIdParameter;
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
    /**
     * Ordering
     */
    order?: OrderParameter;
    /**
     * Limiting and Pagination
     */
    offset?: OffsetParameter;
    /**
     * Limiting and Pagination
     */
    limit?: LimitParameter;
};
export type PostWalletParams = {
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
};
export type DeleteWalletParams = {
    wallet_id?: RowFilterWalletWalletIdParameter;
    balance?: RowFilterWalletBalanceParameter;
    created_at?: RowFilterWalletCreatedAtParameter;
    updated_at?: RowFilterWalletUpdatedAtParameter;
    currency_id?: RowFilterWalletCurrencyIdParameter;
    user_id?: RowFilterWalletUserIdParameter;
};
export type PatchWalletParams = {
    wallet_id?: RowFilterWalletWalletIdParameter;
    balance?: RowFilterWalletBalanceParameter;
    created_at?: RowFilterWalletCreatedAtParameter;
    updated_at?: RowFilterWalletUpdatedAtParameter;
    currency_id?: RowFilterWalletCurrencyIdParameter;
    user_id?: RowFilterWalletUserIdParameter;
};
export type GetUserParams = {
    photo_url?: RowFilterUserPhotoUrlParameter;
    user_id?: RowFilterUserUserIdParameter;
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
    /**
     * Ordering
     */
    order?: OrderParameter;
    /**
     * Limiting and Pagination
     */
    offset?: OffsetParameter;
    /**
     * Limiting and Pagination
     */
    limit?: LimitParameter;
};
export type PostUserParams = {
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
};
export type DeleteUserParams = {
    photo_url?: RowFilterUserPhotoUrlParameter;
    user_id?: RowFilterUserUserIdParameter;
};
export type PatchUserParams = {
    photo_url?: RowFilterUserPhotoUrlParameter;
    user_id?: RowFilterUserUserIdParameter;
};
export type GetTransactionParams = {
    transaction_id?: RowFilterTransactionTransactionIdParameter;
    wallet_id?: RowFilterTransactionWalletIdParameter;
    transaction_type_id?: RowFilterTransactionTransactionTypeIdParameter;
    amount?: RowFilterTransactionAmountParameter;
    transaction_date?: RowFilterTransactionTransactionDateParameter;
    description?: RowFilterTransactionDescriptionParameter;
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
    /**
     * Ordering
     */
    order?: OrderParameter;
    /**
     * Limiting and Pagination
     */
    offset?: OffsetParameter;
    /**
     * Limiting and Pagination
     */
    limit?: LimitParameter;
};
export type PostTransactionParams = {
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
};
export type DeleteTransactionParams = {
    transaction_id?: RowFilterTransactionTransactionIdParameter;
    wallet_id?: RowFilterTransactionWalletIdParameter;
    transaction_type_id?: RowFilterTransactionTransactionTypeIdParameter;
    amount?: RowFilterTransactionAmountParameter;
    transaction_date?: RowFilterTransactionTransactionDateParameter;
    description?: RowFilterTransactionDescriptionParameter;
};
export type PatchTransactionParams = {
    transaction_id?: RowFilterTransactionTransactionIdParameter;
    wallet_id?: RowFilterTransactionWalletIdParameter;
    transaction_type_id?: RowFilterTransactionTransactionTypeIdParameter;
    amount?: RowFilterTransactionAmountParameter;
    transaction_date?: RowFilterTransactionTransactionDateParameter;
    description?: RowFilterTransactionDescriptionParameter;
};
export type GetCurrencyParams = {
    currency_id?: RowFilterCurrencyCurrencyIdParameter;
    name?: RowFilterCurrencyNameParameter;
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
    /**
     * Ordering
     */
    order?: OrderParameter;
    /**
     * Limiting and Pagination
     */
    offset?: OffsetParameter;
    /**
     * Limiting and Pagination
     */
    limit?: LimitParameter;
};
export type PostCurrencyParams = {
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
};
export type DeleteCurrencyParams = {
    currency_id?: RowFilterCurrencyCurrencyIdParameter;
    name?: RowFilterCurrencyNameParameter;
};
export type PatchCurrencyParams = {
    currency_id?: RowFilterCurrencyCurrencyIdParameter;
    name?: RowFilterCurrencyNameParameter;
};
export type GetTransactionTypeParams = {
    transaction_type_id?: RowFilterTransactionTypeTransactionTypeIdParameter;
    name?: RowFilterTransactionTypeNameParameter;
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
    /**
     * Ordering
     */
    order?: OrderParameter;
    /**
     * Limiting and Pagination
     */
    offset?: OffsetParameter;
    /**
     * Limiting and Pagination
     */
    limit?: LimitParameter;
};
export type PostTransactionTypeParams = {
    /**
     * Filtering Columns
     */
    select?: SelectParameter;
};
export type DeleteTransactionTypeParams = {
    transaction_type_id?: RowFilterTransactionTypeTransactionTypeIdParameter;
    name?: RowFilterTransactionTypeNameParameter;
};
export type PatchTransactionTypeParams = {
    transaction_type_id?: RowFilterTransactionTypeTransactionTypeIdParameter;
    name?: RowFilterTransactionTypeNameParameter;
};
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];
/**
 * @summary OpenAPI description (this document)
 */
export const get = (options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<null>({ url: `/`, method: 'GET', signal
    }, options);
};
export const getGetQueryKey = () => {
    return [`/`] as const;
};
export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};
    const queryKey = queryOptions?.queryKey ?? getGetQueryKey();
    const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(requestOptions, signal);
    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};
export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = unknown;
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> & Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> & Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary OpenAPI description (this document)
 */
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetQueryOptions(options);
    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
    query.queryKey = queryOptions.queryKey;
    return query;
}
export const getWallet = (params?: GetWalletParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<Wallet[] | null>({ url: `/wallet`, method: 'GET',
        params, signal
    }, options);
};
export const getGetWalletQueryKey = (params?: GetWalletParams) => {
    return [`/wallet`, ...(params ? [params] : [])] as const;
};
export const getGetWalletQueryOptions = <TData = Awaited<ReturnType<typeof getWallet>>, TError = unknown>(params?: GetWalletParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallet>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};
    const queryKey = queryOptions?.queryKey ?? getGetWalletQueryKey(params);
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWallet>>> = ({ signal }) => getWallet(params, requestOptions, signal);
    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getWallet>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};
export type GetWalletQueryResult = NonNullable<Awaited<ReturnType<typeof getWallet>>>;
export type GetWalletQueryError = unknown;
export function useGetWallet<TData = Awaited<ReturnType<typeof getWallet>>, TError = unknown>(params: undefined | GetWalletParams, options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallet>>, TError, TData>> & Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getWallet>>, TError, Awaited<ReturnType<typeof getWallet>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWallet<TData = Awaited<ReturnType<typeof getWallet>>, TError = unknown>(params?: GetWalletParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallet>>, TError, TData>> & Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getWallet>>, TError, Awaited<ReturnType<typeof getWallet>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWallet<TData = Awaited<ReturnType<typeof getWallet>>, TError = unknown>(params?: GetWalletParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallet>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetWallet<TData = Awaited<ReturnType<typeof getWallet>>, TError = unknown>(params?: GetWalletParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallet>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetWalletQueryOptions(params, options);
    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
    query.queryKey = queryOptions.queryKey;
    return query;
}
export const postWallet = (walletBody: WalletBody, params?: PostWalletParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<null>({ url: `/wallet`, method: 'POST',
        headers: { 'Content-Type': 'application/json', },
        data: walletBody,
        params, signal
    }, options);
};
export const getPostWalletMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postWallet>>, TError, {
        data: WalletBody;
        params?: PostWalletParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof postWallet>>, TError, {
    data: WalletBody;
    params?: PostWalletParams;
}, TContext> => {
    const mutationKey = ['postWallet'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postWallet>>, {
        data: WalletBody;
        params?: PostWalletParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return postWallet(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PostWalletMutationResult = NonNullable<Awaited<ReturnType<typeof postWallet>>>;
export type PostWalletMutationBody = WalletBody;
export type PostWalletMutationError = unknown;
export const usePostWallet = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postWallet>>, TError, {
        data: WalletBody;
        params?: PostWalletParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof postWallet>>, TError, {
    data: WalletBody;
    params?: PostWalletParams;
}, TContext> => {
    const mutationOptions = getPostWalletMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const deleteWallet = (params?: DeleteWalletParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/wallet`, method: 'DELETE',
        params
    }, options);
};
export const getDeleteWalletMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteWallet>>, TError, {
        params?: DeleteWalletParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteWallet>>, TError, {
    params?: DeleteWalletParams;
}, TContext> => {
    const mutationKey = ['deleteWallet'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWallet>>, {
        params?: DeleteWalletParams;
    }> = (props) => {
        const { params } = props ?? {};
        return deleteWallet(params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type DeleteWalletMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWallet>>>;
export type DeleteWalletMutationError = unknown;
export const useDeleteWallet = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteWallet>>, TError, {
        params?: DeleteWalletParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof deleteWallet>>, TError, {
    params?: DeleteWalletParams;
}, TContext> => {
    const mutationOptions = getDeleteWalletMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const patchWallet = (walletBody: WalletBody, params?: PatchWalletParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/wallet`, method: 'PATCH',
        headers: { 'Content-Type': 'application/json', },
        data: walletBody,
        params
    }, options);
};
export const getPatchWalletMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchWallet>>, TError, {
        data: WalletBody;
        params?: PatchWalletParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchWallet>>, TError, {
    data: WalletBody;
    params?: PatchWalletParams;
}, TContext> => {
    const mutationKey = ['patchWallet'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchWallet>>, {
        data: WalletBody;
        params?: PatchWalletParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return patchWallet(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PatchWalletMutationResult = NonNullable<Awaited<ReturnType<typeof patchWallet>>>;
export type PatchWalletMutationBody = WalletBody;
export type PatchWalletMutationError = unknown;
export const usePatchWallet = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchWallet>>, TError, {
        data: WalletBody;
        params?: PatchWalletParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof patchWallet>>, TError, {
    data: WalletBody;
    params?: PatchWalletParams;
}, TContext> => {
    const mutationOptions = getPatchWalletMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const getUser = (params?: GetUserParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<User[] | null>({ url: `/user`, method: 'GET',
        params, signal
    }, options);
};
export const getGetUserQueryKey = (params?: GetUserParams) => {
    return [`/user`, ...(params ? [params] : [])] as const;
};
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(params?: GetUserParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};
    const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(params);
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(params, requestOptions, signal);
    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};
export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type GetUserQueryError = unknown;
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(params: undefined | GetUserParams, options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getUser>>, TError, Awaited<ReturnType<typeof getUser>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(params?: GetUserParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getUser>>, TError, Awaited<ReturnType<typeof getUser>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(params?: GetUserParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(params?: GetUserParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetUserQueryOptions(params, options);
    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
    query.queryKey = queryOptions.queryKey;
    return query;
}
export const postUser = (userBody: UserBody, params?: PostUserParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<null>({ url: `/user`, method: 'POST',
        headers: { 'Content-Type': 'application/json', },
        data: userBody,
        params, signal
    }, options);
};
export const getPostUserMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUser>>, TError, {
        data: UserBody;
        params?: PostUserParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof postUser>>, TError, {
    data: UserBody;
    params?: PostUserParams;
}, TContext> => {
    const mutationKey = ['postUser'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUser>>, {
        data: UserBody;
        params?: PostUserParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return postUser(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PostUserMutationResult = NonNullable<Awaited<ReturnType<typeof postUser>>>;
export type PostUserMutationBody = UserBody;
export type PostUserMutationError = unknown;
export const usePostUser = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postUser>>, TError, {
        data: UserBody;
        params?: PostUserParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof postUser>>, TError, {
    data: UserBody;
    params?: PostUserParams;
}, TContext> => {
    const mutationOptions = getPostUserMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const deleteUser = (params?: DeleteUserParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/user`, method: 'DELETE',
        params
    }, options);
};
export const getDeleteUserMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, {
        params?: DeleteUserParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, {
    params?: DeleteUserParams;
}, TContext> => {
    const mutationKey = ['deleteUser'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {
        params?: DeleteUserParams;
    }> = (props) => {
        const { params } = props ?? {};
        return deleteUser(params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>;
export type DeleteUserMutationError = unknown;
export const useDeleteUser = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError, {
        params?: DeleteUserParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof deleteUser>>, TError, {
    params?: DeleteUserParams;
}, TContext> => {
    const mutationOptions = getDeleteUserMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const patchUser = (userBody: UserBody, params?: PatchUserParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/user`, method: 'PATCH',
        headers: { 'Content-Type': 'application/json', },
        data: userBody,
        params
    }, options);
};
export const getPatchUserMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchUser>>, TError, {
        data: UserBody;
        params?: PatchUserParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchUser>>, TError, {
    data: UserBody;
    params?: PatchUserParams;
}, TContext> => {
    const mutationKey = ['patchUser'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUser>>, {
        data: UserBody;
        params?: PatchUserParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return patchUser(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PatchUserMutationResult = NonNullable<Awaited<ReturnType<typeof patchUser>>>;
export type PatchUserMutationBody = UserBody;
export type PatchUserMutationError = unknown;
export const usePatchUser = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchUser>>, TError, {
        data: UserBody;
        params?: PatchUserParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof patchUser>>, TError, {
    data: UserBody;
    params?: PatchUserParams;
}, TContext> => {
    const mutationOptions = getPatchUserMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const getTransaction = (params?: GetTransactionParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<Transaction[] | null>({ url: `/transaction`, method: 'GET',
        params, signal
    }, options);
};
export const getGetTransactionQueryKey = (params?: GetTransactionParams) => {
    return [`/transaction`, ...(params ? [params] : [])] as const;
};
export const getGetTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getTransaction>>, TError = unknown>(params?: GetTransactionParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransaction>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};
    const queryKey = queryOptions?.queryKey ?? getGetTransactionQueryKey(params);
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransaction>>> = ({ signal }) => getTransaction(params, requestOptions, signal);
    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getTransaction>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};
export type GetTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getTransaction>>>;
export type GetTransactionQueryError = unknown;
export function useGetTransaction<TData = Awaited<ReturnType<typeof getTransaction>>, TError = unknown>(params: undefined | GetTransactionParams, options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransaction>>, TError, TData>> & Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getTransaction>>, TError, Awaited<ReturnType<typeof getTransaction>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTransaction<TData = Awaited<ReturnType<typeof getTransaction>>, TError = unknown>(params?: GetTransactionParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransaction>>, TError, TData>> & Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTransaction>>, TError, Awaited<ReturnType<typeof getTransaction>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTransaction<TData = Awaited<ReturnType<typeof getTransaction>>, TError = unknown>(params?: GetTransactionParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransaction>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTransaction<TData = Awaited<ReturnType<typeof getTransaction>>, TError = unknown>(params?: GetTransactionParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransaction>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetTransactionQueryOptions(params, options);
    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
    query.queryKey = queryOptions.queryKey;
    return query;
}
export const postTransaction = (transactionBody: TransactionBody, params?: PostTransactionParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<null>({ url: `/transaction`, method: 'POST',
        headers: { 'Content-Type': 'application/json', },
        data: transactionBody,
        params, signal
    }, options);
};
export const getPostTransactionMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postTransaction>>, TError, {
        data: TransactionBody;
        params?: PostTransactionParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof postTransaction>>, TError, {
    data: TransactionBody;
    params?: PostTransactionParams;
}, TContext> => {
    const mutationKey = ['postTransaction'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTransaction>>, {
        data: TransactionBody;
        params?: PostTransactionParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return postTransaction(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PostTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof postTransaction>>>;
export type PostTransactionMutationBody = TransactionBody;
export type PostTransactionMutationError = unknown;
export const usePostTransaction = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postTransaction>>, TError, {
        data: TransactionBody;
        params?: PostTransactionParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof postTransaction>>, TError, {
    data: TransactionBody;
    params?: PostTransactionParams;
}, TContext> => {
    const mutationOptions = getPostTransactionMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const deleteTransaction = (params?: DeleteTransactionParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/transaction`, method: 'DELETE',
        params
    }, options);
};
export const getDeleteTransactionMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTransaction>>, TError, {
        params?: DeleteTransactionParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteTransaction>>, TError, {
    params?: DeleteTransactionParams;
}, TContext> => {
    const mutationKey = ['deleteTransaction'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTransaction>>, {
        params?: DeleteTransactionParams;
    }> = (props) => {
        const { params } = props ?? {};
        return deleteTransaction(params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type DeleteTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTransaction>>>;
export type DeleteTransactionMutationError = unknown;
export const useDeleteTransaction = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTransaction>>, TError, {
        params?: DeleteTransactionParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof deleteTransaction>>, TError, {
    params?: DeleteTransactionParams;
}, TContext> => {
    const mutationOptions = getDeleteTransactionMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const patchTransaction = (transactionBody: TransactionBody, params?: PatchTransactionParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/transaction`, method: 'PATCH',
        headers: { 'Content-Type': 'application/json', },
        data: transactionBody,
        params
    }, options);
};
export const getPatchTransactionMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchTransaction>>, TError, {
        data: TransactionBody;
        params?: PatchTransactionParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchTransaction>>, TError, {
    data: TransactionBody;
    params?: PatchTransactionParams;
}, TContext> => {
    const mutationKey = ['patchTransaction'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTransaction>>, {
        data: TransactionBody;
        params?: PatchTransactionParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return patchTransaction(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PatchTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof patchTransaction>>>;
export type PatchTransactionMutationBody = TransactionBody;
export type PatchTransactionMutationError = unknown;
export const usePatchTransaction = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchTransaction>>, TError, {
        data: TransactionBody;
        params?: PatchTransactionParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof patchTransaction>>, TError, {
    data: TransactionBody;
    params?: PatchTransactionParams;
}, TContext> => {
    const mutationOptions = getPatchTransactionMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const getCurrency = (params?: GetCurrencyParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<Currency[] | null>({ url: `/currency`, method: 'GET',
        params, signal
    }, options);
};
export const getGetCurrencyQueryKey = (params?: GetCurrencyParams) => {
    return [`/currency`, ...(params ? [params] : [])] as const;
};
export const getGetCurrencyQueryOptions = <TData = Awaited<ReturnType<typeof getCurrency>>, TError = unknown>(params?: GetCurrencyParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrency>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};
    const queryKey = queryOptions?.queryKey ?? getGetCurrencyQueryKey(params);
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrency>>> = ({ signal }) => getCurrency(params, requestOptions, signal);
    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getCurrency>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};
export type GetCurrencyQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrency>>>;
export type GetCurrencyQueryError = unknown;
export function useGetCurrency<TData = Awaited<ReturnType<typeof getCurrency>>, TError = unknown>(params: undefined | GetCurrencyParams, options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrency>>, TError, TData>> & Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getCurrency>>, TError, Awaited<ReturnType<typeof getCurrency>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrency<TData = Awaited<ReturnType<typeof getCurrency>>, TError = unknown>(params?: GetCurrencyParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrency>>, TError, TData>> & Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getCurrency>>, TError, Awaited<ReturnType<typeof getCurrency>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrency<TData = Awaited<ReturnType<typeof getCurrency>>, TError = unknown>(params?: GetCurrencyParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrency>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrency<TData = Awaited<ReturnType<typeof getCurrency>>, TError = unknown>(params?: GetCurrencyParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrency>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetCurrencyQueryOptions(params, options);
    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
    query.queryKey = queryOptions.queryKey;
    return query;
}
export const postCurrency = (currencyBody: CurrencyBody, params?: PostCurrencyParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<null>({ url: `/currency`, method: 'POST',
        headers: { 'Content-Type': 'application/json', },
        data: currencyBody,
        params, signal
    }, options);
};
export const getPostCurrencyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postCurrency>>, TError, {
        data: CurrencyBody;
        params?: PostCurrencyParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof postCurrency>>, TError, {
    data: CurrencyBody;
    params?: PostCurrencyParams;
}, TContext> => {
    const mutationKey = ['postCurrency'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCurrency>>, {
        data: CurrencyBody;
        params?: PostCurrencyParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return postCurrency(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PostCurrencyMutationResult = NonNullable<Awaited<ReturnType<typeof postCurrency>>>;
export type PostCurrencyMutationBody = CurrencyBody;
export type PostCurrencyMutationError = unknown;
export const usePostCurrency = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postCurrency>>, TError, {
        data: CurrencyBody;
        params?: PostCurrencyParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof postCurrency>>, TError, {
    data: CurrencyBody;
    params?: PostCurrencyParams;
}, TContext> => {
    const mutationOptions = getPostCurrencyMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const deleteCurrency = (params?: DeleteCurrencyParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/currency`, method: 'DELETE',
        params
    }, options);
};
export const getDeleteCurrencyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteCurrency>>, TError, {
        params?: DeleteCurrencyParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteCurrency>>, TError, {
    params?: DeleteCurrencyParams;
}, TContext> => {
    const mutationKey = ['deleteCurrency'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrency>>, {
        params?: DeleteCurrencyParams;
    }> = (props) => {
        const { params } = props ?? {};
        return deleteCurrency(params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type DeleteCurrencyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrency>>>;
export type DeleteCurrencyMutationError = unknown;
export const useDeleteCurrency = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteCurrency>>, TError, {
        params?: DeleteCurrencyParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof deleteCurrency>>, TError, {
    params?: DeleteCurrencyParams;
}, TContext> => {
    const mutationOptions = getDeleteCurrencyMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const patchCurrency = (currencyBody: CurrencyBody, params?: PatchCurrencyParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/currency`, method: 'PATCH',
        headers: { 'Content-Type': 'application/json', },
        data: currencyBody,
        params
    }, options);
};
export const getPatchCurrencyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchCurrency>>, TError, {
        data: CurrencyBody;
        params?: PatchCurrencyParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchCurrency>>, TError, {
    data: CurrencyBody;
    params?: PatchCurrencyParams;
}, TContext> => {
    const mutationKey = ['patchCurrency'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchCurrency>>, {
        data: CurrencyBody;
        params?: PatchCurrencyParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return patchCurrency(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PatchCurrencyMutationResult = NonNullable<Awaited<ReturnType<typeof patchCurrency>>>;
export type PatchCurrencyMutationBody = CurrencyBody;
export type PatchCurrencyMutationError = unknown;
export const usePatchCurrency = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchCurrency>>, TError, {
        data: CurrencyBody;
        params?: PatchCurrencyParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof patchCurrency>>, TError, {
    data: CurrencyBody;
    params?: PatchCurrencyParams;
}, TContext> => {
    const mutationOptions = getPatchCurrencyMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const getTransactionType = (params?: GetTransactionTypeParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<TransactionType[] | null>({ url: `/transactionType`, method: 'GET',
        params, signal
    }, options);
};
export const getGetTransactionTypeQueryKey = (params?: GetTransactionTypeParams) => {
    return [`/transactionType`, ...(params ? [params] : [])] as const;
};
export const getGetTransactionTypeQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionType>>, TError = unknown>(params?: GetTransactionTypeParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};
    const queryKey = queryOptions?.queryKey ?? getGetTransactionTypeQueryKey(params);
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionType>>> = ({ signal }) => getTransactionType(params, requestOptions, signal);
    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};
export type GetTransactionTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionType>>>;
export type GetTransactionTypeQueryError = unknown;
export function useGetTransactionType<TData = Awaited<ReturnType<typeof getTransactionType>>, TError = unknown>(params: undefined | GetTransactionTypeParams, options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, TData>> & Pick<DefinedInitialDataOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, Awaited<ReturnType<typeof getTransactionType>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): DefinedUseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTransactionType<TData = Awaited<ReturnType<typeof getTransactionType>>, TError = unknown>(params?: GetTransactionTypeParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, TData>> & Pick<UndefinedInitialDataOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, Awaited<ReturnType<typeof getTransactionType>>>, 'initialData'>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTransactionType<TData = Awaited<ReturnType<typeof getTransactionType>>, TError = unknown>(params?: GetTransactionTypeParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTransactionType<TData = Awaited<ReturnType<typeof getTransactionType>>, TError = unknown>(params?: GetTransactionTypeParams, options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionType>>, TError, TData>>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
} {
    const queryOptions = getGetTransactionTypeQueryOptions(params, options);
    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
    query.queryKey = queryOptions.queryKey;
    return query;
}
export const postTransactionType = (transactionTypeBody: TransactionTypeBody, params?: PostTransactionTypeParams, options?: SecondParameter<typeof customAxios>, signal?: AbortSignal) => {
    return customAxios<null>({ url: `/transactionType`, method: 'POST',
        headers: { 'Content-Type': 'application/json', },
        data: transactionTypeBody,
        params, signal
    }, options);
};
export const getPostTransactionTypeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postTransactionType>>, TError, {
        data: TransactionTypeBody;
        params?: PostTransactionTypeParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof postTransactionType>>, TError, {
    data: TransactionTypeBody;
    params?: PostTransactionTypeParams;
}, TContext> => {
    const mutationKey = ['postTransactionType'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTransactionType>>, {
        data: TransactionTypeBody;
        params?: PostTransactionTypeParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return postTransactionType(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PostTransactionTypeMutationResult = NonNullable<Awaited<ReturnType<typeof postTransactionType>>>;
export type PostTransactionTypeMutationBody = TransactionTypeBody;
export type PostTransactionTypeMutationError = unknown;
export const usePostTransactionType = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postTransactionType>>, TError, {
        data: TransactionTypeBody;
        params?: PostTransactionTypeParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof postTransactionType>>, TError, {
    data: TransactionTypeBody;
    params?: PostTransactionTypeParams;
}, TContext> => {
    const mutationOptions = getPostTransactionTypeMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const deleteTransactionType = (params?: DeleteTransactionTypeParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/transactionType`, method: 'DELETE',
        params
    }, options);
};
export const getDeleteTransactionTypeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionType>>, TError, {
        params?: DeleteTransactionTypeParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionType>>, TError, {
    params?: DeleteTransactionTypeParams;
}, TContext> => {
    const mutationKey = ['deleteTransactionType'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTransactionType>>, {
        params?: DeleteTransactionTypeParams;
    }> = (props) => {
        const { params } = props ?? {};
        return deleteTransactionType(params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type DeleteTransactionTypeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTransactionType>>>;
export type DeleteTransactionTypeMutationError = unknown;
export const useDeleteTransactionType = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionType>>, TError, {
        params?: DeleteTransactionTypeParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof deleteTransactionType>>, TError, {
    params?: DeleteTransactionTypeParams;
}, TContext> => {
    const mutationOptions = getDeleteTransactionTypeMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};
export const patchTransactionType = (transactionTypeBody: TransactionTypeBody, params?: PatchTransactionTypeParams, options?: SecondParameter<typeof customAxios>) => {
    return customAxios<null>({ url: `/transactionType`, method: 'PATCH',
        headers: { 'Content-Type': 'application/json', },
        data: transactionTypeBody,
        params
    }, options);
};
export const getPatchTransactionTypeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchTransactionType>>, TError, {
        data: TransactionTypeBody;
        params?: PatchTransactionTypeParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}): UseMutationOptions<Awaited<ReturnType<typeof patchTransactionType>>, TError, {
    data: TransactionTypeBody;
    params?: PatchTransactionTypeParams;
}, TContext> => {
    const mutationKey = ['patchTransactionType'];
    const { mutation: mutationOptions, request: requestOptions } = options ?
        options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
            options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey, }, request: undefined };
    const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTransactionType>>, {
        data: TransactionTypeBody;
        params?: PatchTransactionTypeParams;
    }> = (props) => {
        const { data, params } = props ?? {};
        return patchTransactionType(data, params, requestOptions);
    };
    return { mutationFn, ...mutationOptions };
};
export type PatchTransactionTypeMutationResult = NonNullable<Awaited<ReturnType<typeof patchTransactionType>>>;
export type PatchTransactionTypeMutationBody = TransactionTypeBody;
export type PatchTransactionTypeMutationError = unknown;
export const usePatchTransactionType = <TError = unknown, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof patchTransactionType>>, TError, {
        data: TransactionTypeBody;
        params?: PatchTransactionTypeParams;
    }, TContext>;
    request?: SecondParameter<typeof customAxios>;
}, queryClient?: QueryClient): UseMutationResult<Awaited<ReturnType<typeof patchTransactionType>>, TError, {
    data: TransactionTypeBody;
    params?: PatchTransactionTypeParams;
}, TContext> => {
    const mutationOptions = getPatchTransactionTypeMutationOptions(options);
    return useMutation(mutationOptions, queryClient);
};