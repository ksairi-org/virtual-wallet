/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * PostgREST API
 * This is a dynamic API generated by PostgREST
 * OpenAPI spec version: 13.0.4
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customAxios } from '../libs/react-query-sdk/custom-axios';
export interface Transactions {
  /** Note:
This is a Primary Key.<pk/> */
  transaction_id: number;
  /** Note:
This is a Foreign Key to `Wallets.wallet_id`.<fk table='Wallets' column='wallet_id'/> */
  wallet_id: number;
  /** Note:
This is a Foreign Key to `TransactionTypes.transaction_type_id`.<fk table='TransactionTypes' column='transaction_type_id'/> */
  transaction_type_id: number;
  amount: number;
  transaction_date?: string;
  description?: string;
}

export interface TransactionTypes {
  /** Note:
This is a Primary Key.<pk/> */
  transaction_type_id: number;
  /** @maxLength 50 */
  name: string;
}

export interface Users {
  /** Note:
This is a Primary Key.<pk/> */
  user_id: number;
  /** @maxLength 255 */
  email: string;
  /** @maxLength 255 */
  password?: string;
  /** @maxLength 255 */
  google_id?: string;
  /** @maxLength 255 */
  apple_id?: string;
  created_at?: string;
  updated_at?: string;
}

export interface Currencies {
  /** Note:
This is a Primary Key.<pk/> */
  currency_id: number;
  /** @maxLength 10 */
  name: string;
}

export interface Wallets {
  /** Note:
This is a Primary Key.<pk/> */
  wallet_id: number;
  /** Note:
This is a Foreign Key to `Users.user_id`.<fk table='Users' column='user_id'/> */
  user_id: number;
  balance: number;
  created_at?: string;
  updated_at?: string;
  /** Note:
This is a Foreign Key to `Currencies.currency_id`.<fk table='Currencies' column='currency_id'/> */
  currency_id: number;
}

/**
 * Wallets
 */
export type WalletsBody = Wallets;

/**
 * Transactions
 */
export type TransactionsBody = Transactions;

/**
 * TransactionTypes
 */
export type TransactionTypesBody = TransactionTypes;

/**
 * Users
 */
export type UsersBody = Users;

/**
 * Currencies
 */
export type CurrenciesBody = Currencies;

export type PreferParamsParameter = typeof PreferParamsParameter[keyof typeof PreferParamsParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferParamsParameter = {
} as const;

export type PreferReturnParameter = typeof PreferReturnParameter[keyof typeof PreferReturnParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferReturnParameter = {
  'return=representation': 'return=representation',
  'return=minimal': 'return=minimal',
  'return=none': 'return=none',
} as const;

export type PreferCountParameter = typeof PreferCountParameter[keyof typeof PreferCountParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferCountParameter = {
  'count=none': 'count=none',
} as const;

export type PreferPostParameter = typeof PreferPostParameter[keyof typeof PreferPostParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PreferPostParameter = {
  'return=representation': 'return=representation',
  'return=minimal': 'return=minimal',
  'return=none': 'return=none',
  'resolution=ignore-duplicates': 'resolution=ignore-duplicates',
  'resolution=merge-duplicates': 'resolution=merge-duplicates',
} as const;

/**
 * Filtering Columns
 */
export type SelectParameter = string;

/**
 * On Conflict
 */
export type OnConflictParameter = string;

/**
 * Ordering
 */
export type OrderParameter = string;

/**
 * Limiting and Pagination
 */
export type RangeParameter = string;

/**
 * Limiting and Pagination
 */
export type RangeUnitParameter = string;

/**
 * Limiting and Pagination
 */
export type OffsetParameter = string;

/**
 * Limiting and Pagination
 */
export type LimitParameter = string;

export type RowFilterTransactionsTransactionIdParameter = string;

export type RowFilterTransactionsWalletIdParameter = string;

export type RowFilterTransactionsTransactionTypeIdParameter = string;

export type RowFilterTransactionsAmountParameter = string;

export type RowFilterTransactionsTransactionDateParameter = string;

export type RowFilterTransactionsDescriptionParameter = string;

export type RowFilterTransactionTypesTransactionTypeIdParameter = string;

export type RowFilterTransactionTypesNameParameter = string;

export type RowFilterUsersUserIdParameter = string;

export type RowFilterUsersEmailParameter = string;

export type RowFilterUsersPasswordParameter = string;

export type RowFilterUsersGoogleIdParameter = string;

export type RowFilterUsersAppleIdParameter = string;

export type RowFilterUsersCreatedAtParameter = string;

export type RowFilterUsersUpdatedAtParameter = string;

export type RowFilterCurrenciesCurrencyIdParameter = string;

export type RowFilterCurrenciesNameParameter = string;

export type RowFilterWalletsWalletIdParameter = string;

export type RowFilterWalletsUserIdParameter = string;

export type RowFilterWalletsBalanceParameter = string;

export type RowFilterWalletsCreatedAtParameter = string;

export type RowFilterWalletsUpdatedAtParameter = string;

export type RowFilterWalletsCurrencyIdParameter = string;

export type GetTransactionsParams = {
transaction_id?: RowFilterTransactionsTransactionIdParameter;
wallet_id?: RowFilterTransactionsWalletIdParameter;
transaction_type_id?: RowFilterTransactionsTransactionTypeIdParameter;
amount?: RowFilterTransactionsAmountParameter;
transaction_date?: RowFilterTransactionsTransactionDateParameter;
description?: RowFilterTransactionsDescriptionParameter;
/**
 * Filtering Columns
 */
select?: SelectParameter;
/**
 * Ordering
 */
order?: OrderParameter;
/**
 * Limiting and Pagination
 */
offset?: OffsetParameter;
/**
 * Limiting and Pagination
 */
limit?: LimitParameter;
};

export type PostTransactionsParams = {
/**
 * Filtering Columns
 */
select?: SelectParameter;
};

export type DeleteTransactionsParams = {
transaction_id?: RowFilterTransactionsTransactionIdParameter;
wallet_id?: RowFilterTransactionsWalletIdParameter;
transaction_type_id?: RowFilterTransactionsTransactionTypeIdParameter;
amount?: RowFilterTransactionsAmountParameter;
transaction_date?: RowFilterTransactionsTransactionDateParameter;
description?: RowFilterTransactionsDescriptionParameter;
};

export type PatchTransactionsParams = {
transaction_id?: RowFilterTransactionsTransactionIdParameter;
wallet_id?: RowFilterTransactionsWalletIdParameter;
transaction_type_id?: RowFilterTransactionsTransactionTypeIdParameter;
amount?: RowFilterTransactionsAmountParameter;
transaction_date?: RowFilterTransactionsTransactionDateParameter;
description?: RowFilterTransactionsDescriptionParameter;
};

export type GetTransactionTypesParams = {
transaction_type_id?: RowFilterTransactionTypesTransactionTypeIdParameter;
name?: RowFilterTransactionTypesNameParameter;
/**
 * Filtering Columns
 */
select?: SelectParameter;
/**
 * Ordering
 */
order?: OrderParameter;
/**
 * Limiting and Pagination
 */
offset?: OffsetParameter;
/**
 * Limiting and Pagination
 */
limit?: LimitParameter;
};

export type PostTransactionTypesParams = {
/**
 * Filtering Columns
 */
select?: SelectParameter;
};

export type DeleteTransactionTypesParams = {
transaction_type_id?: RowFilterTransactionTypesTransactionTypeIdParameter;
name?: RowFilterTransactionTypesNameParameter;
};

export type PatchTransactionTypesParams = {
transaction_type_id?: RowFilterTransactionTypesTransactionTypeIdParameter;
name?: RowFilterTransactionTypesNameParameter;
};

export type GetUsersParams = {
user_id?: RowFilterUsersUserIdParameter;
email?: RowFilterUsersEmailParameter;
password?: RowFilterUsersPasswordParameter;
google_id?: RowFilterUsersGoogleIdParameter;
apple_id?: RowFilterUsersAppleIdParameter;
created_at?: RowFilterUsersCreatedAtParameter;
updated_at?: RowFilterUsersUpdatedAtParameter;
/**
 * Filtering Columns
 */
select?: SelectParameter;
/**
 * Ordering
 */
order?: OrderParameter;
/**
 * Limiting and Pagination
 */
offset?: OffsetParameter;
/**
 * Limiting and Pagination
 */
limit?: LimitParameter;
};

export type PostUsersParams = {
/**
 * Filtering Columns
 */
select?: SelectParameter;
};

export type DeleteUsersParams = {
user_id?: RowFilterUsersUserIdParameter;
email?: RowFilterUsersEmailParameter;
password?: RowFilterUsersPasswordParameter;
google_id?: RowFilterUsersGoogleIdParameter;
apple_id?: RowFilterUsersAppleIdParameter;
created_at?: RowFilterUsersCreatedAtParameter;
updated_at?: RowFilterUsersUpdatedAtParameter;
};

export type PatchUsersParams = {
user_id?: RowFilterUsersUserIdParameter;
email?: RowFilterUsersEmailParameter;
password?: RowFilterUsersPasswordParameter;
google_id?: RowFilterUsersGoogleIdParameter;
apple_id?: RowFilterUsersAppleIdParameter;
created_at?: RowFilterUsersCreatedAtParameter;
updated_at?: RowFilterUsersUpdatedAtParameter;
};

export type GetCurrenciesParams = {
currency_id?: RowFilterCurrenciesCurrencyIdParameter;
name?: RowFilterCurrenciesNameParameter;
/**
 * Filtering Columns
 */
select?: SelectParameter;
/**
 * Ordering
 */
order?: OrderParameter;
/**
 * Limiting and Pagination
 */
offset?: OffsetParameter;
/**
 * Limiting and Pagination
 */
limit?: LimitParameter;
};

export type PostCurrenciesParams = {
/**
 * Filtering Columns
 */
select?: SelectParameter;
};

export type DeleteCurrenciesParams = {
currency_id?: RowFilterCurrenciesCurrencyIdParameter;
name?: RowFilterCurrenciesNameParameter;
};

export type PatchCurrenciesParams = {
currency_id?: RowFilterCurrenciesCurrencyIdParameter;
name?: RowFilterCurrenciesNameParameter;
};

export type GetWalletsParams = {
wallet_id?: RowFilterWalletsWalletIdParameter;
user_id?: RowFilterWalletsUserIdParameter;
balance?: RowFilterWalletsBalanceParameter;
created_at?: RowFilterWalletsCreatedAtParameter;
updated_at?: RowFilterWalletsUpdatedAtParameter;
currency_id?: RowFilterWalletsCurrencyIdParameter;
/**
 * Filtering Columns
 */
select?: SelectParameter;
/**
 * Ordering
 */
order?: OrderParameter;
/**
 * Limiting and Pagination
 */
offset?: OffsetParameter;
/**
 * Limiting and Pagination
 */
limit?: LimitParameter;
};

export type PostWalletsParams = {
/**
 * Filtering Columns
 */
select?: SelectParameter;
};

export type DeleteWalletsParams = {
wallet_id?: RowFilterWalletsWalletIdParameter;
user_id?: RowFilterWalletsUserIdParameter;
balance?: RowFilterWalletsBalanceParameter;
created_at?: RowFilterWalletsCreatedAtParameter;
updated_at?: RowFilterWalletsUpdatedAtParameter;
currency_id?: RowFilterWalletsCurrencyIdParameter;
};

export type PatchWalletsParams = {
wallet_id?: RowFilterWalletsWalletIdParameter;
user_id?: RowFilterWalletsUserIdParameter;
balance?: RowFilterWalletsBalanceParameter;
created_at?: RowFilterWalletsCreatedAtParameter;
updated_at?: RowFilterWalletsUpdatedAtParameter;
currency_id?: RowFilterWalletsCurrencyIdParameter;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary OpenAPI description (this document)
 */
export const get = (
    
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<null>(
      {url: `/`, method: 'GET', signal
    },
      options);
    }
  

export const getGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = unknown


export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          Awaited<ReturnType<typeof get>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          Awaited<ReturnType<typeof get>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary OpenAPI description (this document)
 */

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTransactions = (
    params?: GetTransactionsParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<Transactions[] | null>(
      {url: `/Transactions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTransactionsQueryKey = (params?: GetTransactionsParams,) => {
    return [`/Transactions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getTransactions>>, TError = unknown>(params?: GetTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactions>>> = ({ signal }) => getTransactions(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactions>>>
export type GetTransactionsQueryError = unknown


export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = unknown>(
 params: undefined |  GetTransactionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactions>>,
          TError,
          Awaited<ReturnType<typeof getTransactions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = unknown>(
 params?: GetTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactions>>,
          TError,
          Awaited<ReturnType<typeof getTransactions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = unknown>(
 params?: GetTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTransactions<TData = Awaited<ReturnType<typeof getTransactions>>, TError = unknown>(
 params?: GetTransactionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactions>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postTransactions = (
    transactionsBody: TransactionsBody,
    params?: PostTransactionsParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<null>(
      {url: `/Transactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: transactionsBody,
        params, signal
    },
      options);
    }
  


export const getPostTransactionsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTransactions>>, TError,{data: TransactionsBody;params?: PostTransactionsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof postTransactions>>, TError,{data: TransactionsBody;params?: PostTransactionsParams}, TContext> => {

const mutationKey = ['postTransactions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTransactions>>, {data: TransactionsBody;params?: PostTransactionsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postTransactions(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof postTransactions>>>
    export type PostTransactionsMutationBody = TransactionsBody
    export type PostTransactionsMutationError = unknown

    export const usePostTransactions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTransactions>>, TError,{data: TransactionsBody;params?: PostTransactionsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTransactions>>,
        TError,
        {data: TransactionsBody;params?: PostTransactionsParams},
        TContext
      > => {

      const mutationOptions = getPostTransactionsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteTransactions = (
    params?: DeleteTransactionsParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Transactions`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteTransactionsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTransactions>>, TError,{params?: DeleteTransactionsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTransactions>>, TError,{params?: DeleteTransactionsParams}, TContext> => {

const mutationKey = ['deleteTransactions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTransactions>>, {params?: DeleteTransactionsParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteTransactions(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTransactions>>>
    
    export type DeleteTransactionsMutationError = unknown

    export const useDeleteTransactions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTransactions>>, TError,{params?: DeleteTransactionsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTransactions>>,
        TError,
        {params?: DeleteTransactionsParams},
        TContext
      > => {

      const mutationOptions = getDeleteTransactionsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const patchTransactions = (
    transactionsBody: TransactionsBody,
    params?: PatchTransactionsParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Transactions`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transactionsBody,
        params
    },
      options);
    }
  


export const getPatchTransactionsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTransactions>>, TError,{data: TransactionsBody;params?: PatchTransactionsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof patchTransactions>>, TError,{data: TransactionsBody;params?: PatchTransactionsParams}, TContext> => {

const mutationKey = ['patchTransactions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTransactions>>, {data: TransactionsBody;params?: PatchTransactionsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  patchTransactions(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof patchTransactions>>>
    export type PatchTransactionsMutationBody = TransactionsBody
    export type PatchTransactionsMutationError = unknown

    export const usePatchTransactions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTransactions>>, TError,{data: TransactionsBody;params?: PatchTransactionsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchTransactions>>,
        TError,
        {data: TransactionsBody;params?: PatchTransactionsParams},
        TContext
      > => {

      const mutationOptions = getPatchTransactionsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getTransactionTypes = (
    params?: GetTransactionTypesParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<TransactionTypes[] | null>(
      {url: `/TransactionTypes`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTransactionTypesQueryKey = (params?: GetTransactionTypesParams,) => {
    return [`/TransactionTypes`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTransactionTypesQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionTypes>>, TError = unknown>(params?: GetTransactionTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionTypes>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionTypesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionTypes>>> = ({ signal }) => getTransactionTypes(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionTypes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionTypesQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionTypes>>>
export type GetTransactionTypesQueryError = unknown


export function useGetTransactionTypes<TData = Awaited<ReturnType<typeof getTransactionTypes>>, TError = unknown>(
 params: undefined |  GetTransactionTypesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionTypes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionTypes>>,
          TError,
          Awaited<ReturnType<typeof getTransactionTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionTypes<TData = Awaited<ReturnType<typeof getTransactionTypes>>, TError = unknown>(
 params?: GetTransactionTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionTypes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionTypes>>,
          TError,
          Awaited<ReturnType<typeof getTransactionTypes>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionTypes<TData = Awaited<ReturnType<typeof getTransactionTypes>>, TError = unknown>(
 params?: GetTransactionTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionTypes>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTransactionTypes<TData = Awaited<ReturnType<typeof getTransactionTypes>>, TError = unknown>(
 params?: GetTransactionTypesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionTypes>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionTypesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postTransactionTypes = (
    transactionTypesBody: TransactionTypesBody,
    params?: PostTransactionTypesParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<null>(
      {url: `/TransactionTypes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: transactionTypesBody,
        params, signal
    },
      options);
    }
  


export const getPostTransactionTypesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTransactionTypes>>, TError,{data: TransactionTypesBody;params?: PostTransactionTypesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof postTransactionTypes>>, TError,{data: TransactionTypesBody;params?: PostTransactionTypesParams}, TContext> => {

const mutationKey = ['postTransactionTypes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTransactionTypes>>, {data: TransactionTypesBody;params?: PostTransactionTypesParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postTransactionTypes(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostTransactionTypesMutationResult = NonNullable<Awaited<ReturnType<typeof postTransactionTypes>>>
    export type PostTransactionTypesMutationBody = TransactionTypesBody
    export type PostTransactionTypesMutationError = unknown

    export const usePostTransactionTypes = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTransactionTypes>>, TError,{data: TransactionTypesBody;params?: PostTransactionTypesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTransactionTypes>>,
        TError,
        {data: TransactionTypesBody;params?: PostTransactionTypesParams},
        TContext
      > => {

      const mutationOptions = getPostTransactionTypesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteTransactionTypes = (
    params?: DeleteTransactionTypesParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/TransactionTypes`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteTransactionTypesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionTypes>>, TError,{params?: DeleteTransactionTypesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionTypes>>, TError,{params?: DeleteTransactionTypesParams}, TContext> => {

const mutationKey = ['deleteTransactionTypes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTransactionTypes>>, {params?: DeleteTransactionTypesParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteTransactionTypes(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTransactionTypesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTransactionTypes>>>
    
    export type DeleteTransactionTypesMutationError = unknown

    export const useDeleteTransactionTypes = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTransactionTypes>>, TError,{params?: DeleteTransactionTypesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTransactionTypes>>,
        TError,
        {params?: DeleteTransactionTypesParams},
        TContext
      > => {

      const mutationOptions = getDeleteTransactionTypesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const patchTransactionTypes = (
    transactionTypesBody: TransactionTypesBody,
    params?: PatchTransactionTypesParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/TransactionTypes`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: transactionTypesBody,
        params
    },
      options);
    }
  


export const getPatchTransactionTypesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTransactionTypes>>, TError,{data: TransactionTypesBody;params?: PatchTransactionTypesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof patchTransactionTypes>>, TError,{data: TransactionTypesBody;params?: PatchTransactionTypesParams}, TContext> => {

const mutationKey = ['patchTransactionTypes'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTransactionTypes>>, {data: TransactionTypesBody;params?: PatchTransactionTypesParams}> = (props) => {
          const {data,params} = props ?? {};

          return  patchTransactionTypes(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchTransactionTypesMutationResult = NonNullable<Awaited<ReturnType<typeof patchTransactionTypes>>>
    export type PatchTransactionTypesMutationBody = TransactionTypesBody
    export type PatchTransactionTypesMutationError = unknown

    export const usePatchTransactionTypes = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTransactionTypes>>, TError,{data: TransactionTypesBody;params?: PatchTransactionTypesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchTransactionTypes>>,
        TError,
        {data: TransactionTypesBody;params?: PatchTransactionTypesParams},
        TContext
      > => {

      const mutationOptions = getPatchTransactionTypesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getUsers = (
    params?: GetUsersParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<Users[] | null>(
      {url: `/Users`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUsersQueryKey = (params?: GetUsersParams,) => {
    return [`/Users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(params?: GetUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = unknown


export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 params: undefined |  GetUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 params?: GetUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsers>>,
          TError,
          Awaited<ReturnType<typeof getUsers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 params?: GetUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = unknown>(
 params?: GetUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postUsers = (
    usersBody: UsersBody,
    params?: PostUsersParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<null>(
      {url: `/Users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: usersBody,
        params, signal
    },
      options);
    }
  


export const getPostUsersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: UsersBody;params?: PostUsersParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: UsersBody;params?: PostUsersParams}, TContext> => {

const mutationKey = ['postUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsers>>, {data: UsersBody;params?: PostUsersParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postUsers(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postUsers>>>
    export type PostUsersMutationBody = UsersBody
    export type PostUsersMutationError = unknown

    export const usePostUsers = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: UsersBody;params?: PostUsersParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postUsers>>,
        TError,
        {data: UsersBody;params?: PostUsersParams},
        TContext
      > => {

      const mutationOptions = getPostUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteUsers = (
    params?: DeleteUsersParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Users`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteUsersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{params?: DeleteUsersParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{params?: DeleteUsersParams}, TContext> => {

const mutationKey = ['deleteUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsers>>, {params?: DeleteUsersParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteUsers(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsers>>>
    
    export type DeleteUsersMutationError = unknown

    export const useDeleteUsers = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{params?: DeleteUsersParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsers>>,
        TError,
        {params?: DeleteUsersParams},
        TContext
      > => {

      const mutationOptions = getDeleteUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const patchUsers = (
    usersBody: UsersBody,
    params?: PatchUsersParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Users`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: usersBody,
        params
    },
      options);
    }
  


export const getPatchUsersMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsers>>, TError,{data: UsersBody;params?: PatchUsersParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof patchUsers>>, TError,{data: UsersBody;params?: PatchUsersParams}, TContext> => {

const mutationKey = ['patchUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUsers>>, {data: UsersBody;params?: PatchUsersParams}> = (props) => {
          const {data,params} = props ?? {};

          return  patchUsers(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchUsersMutationResult = NonNullable<Awaited<ReturnType<typeof patchUsers>>>
    export type PatchUsersMutationBody = UsersBody
    export type PatchUsersMutationError = unknown

    export const usePatchUsers = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsers>>, TError,{data: UsersBody;params?: PatchUsersParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchUsers>>,
        TError,
        {data: UsersBody;params?: PatchUsersParams},
        TContext
      > => {

      const mutationOptions = getPatchUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getCurrencies = (
    params?: GetCurrenciesParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<Currencies[] | null>(
      {url: `/Currencies`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetCurrenciesQueryKey = (params?: GetCurrenciesParams,) => {
    return [`/Currencies`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCurrenciesQueryOptions = <TData = Awaited<ReturnType<typeof getCurrencies>>, TError = unknown>(params?: GetCurrenciesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrencies>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrenciesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrencies>>> = ({ signal }) => getCurrencies(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrencies>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrenciesQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrencies>>>
export type GetCurrenciesQueryError = unknown


export function useGetCurrencies<TData = Awaited<ReturnType<typeof getCurrencies>>, TError = unknown>(
 params: undefined |  GetCurrenciesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrencies>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrencies>>,
          TError,
          Awaited<ReturnType<typeof getCurrencies>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrencies<TData = Awaited<ReturnType<typeof getCurrencies>>, TError = unknown>(
 params?: GetCurrenciesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrencies>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrencies>>,
          TError,
          Awaited<ReturnType<typeof getCurrencies>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrencies<TData = Awaited<ReturnType<typeof getCurrencies>>, TError = unknown>(
 params?: GetCurrenciesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrencies>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCurrencies<TData = Awaited<ReturnType<typeof getCurrencies>>, TError = unknown>(
 params?: GetCurrenciesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrencies>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrenciesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postCurrencies = (
    currenciesBody: CurrenciesBody,
    params?: PostCurrenciesParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<null>(
      {url: `/Currencies`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: currenciesBody,
        params, signal
    },
      options);
    }
  


export const getPostCurrenciesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCurrencies>>, TError,{data: CurrenciesBody;params?: PostCurrenciesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof postCurrencies>>, TError,{data: CurrenciesBody;params?: PostCurrenciesParams}, TContext> => {

const mutationKey = ['postCurrencies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCurrencies>>, {data: CurrenciesBody;params?: PostCurrenciesParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postCurrencies(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostCurrenciesMutationResult = NonNullable<Awaited<ReturnType<typeof postCurrencies>>>
    export type PostCurrenciesMutationBody = CurrenciesBody
    export type PostCurrenciesMutationError = unknown

    export const usePostCurrencies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCurrencies>>, TError,{data: CurrenciesBody;params?: PostCurrenciesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postCurrencies>>,
        TError,
        {data: CurrenciesBody;params?: PostCurrenciesParams},
        TContext
      > => {

      const mutationOptions = getPostCurrenciesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteCurrencies = (
    params?: DeleteCurrenciesParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Currencies`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteCurrenciesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurrencies>>, TError,{params?: DeleteCurrenciesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCurrencies>>, TError,{params?: DeleteCurrenciesParams}, TContext> => {

const mutationKey = ['deleteCurrencies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCurrencies>>, {params?: DeleteCurrenciesParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteCurrencies(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCurrenciesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCurrencies>>>
    
    export type DeleteCurrenciesMutationError = unknown

    export const useDeleteCurrencies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCurrencies>>, TError,{params?: DeleteCurrenciesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCurrencies>>,
        TError,
        {params?: DeleteCurrenciesParams},
        TContext
      > => {

      const mutationOptions = getDeleteCurrenciesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const patchCurrencies = (
    currenciesBody: CurrenciesBody,
    params?: PatchCurrenciesParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Currencies`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: currenciesBody,
        params
    },
      options);
    }
  


export const getPatchCurrenciesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCurrencies>>, TError,{data: CurrenciesBody;params?: PatchCurrenciesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof patchCurrencies>>, TError,{data: CurrenciesBody;params?: PatchCurrenciesParams}, TContext> => {

const mutationKey = ['patchCurrencies'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchCurrencies>>, {data: CurrenciesBody;params?: PatchCurrenciesParams}> = (props) => {
          const {data,params} = props ?? {};

          return  patchCurrencies(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchCurrenciesMutationResult = NonNullable<Awaited<ReturnType<typeof patchCurrencies>>>
    export type PatchCurrenciesMutationBody = CurrenciesBody
    export type PatchCurrenciesMutationError = unknown

    export const usePatchCurrencies = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCurrencies>>, TError,{data: CurrenciesBody;params?: PatchCurrenciesParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchCurrencies>>,
        TError,
        {data: CurrenciesBody;params?: PatchCurrenciesParams},
        TContext
      > => {

      const mutationOptions = getPatchCurrenciesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getWallets = (
    params?: GetWalletsParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<Wallets[] | null>(
      {url: `/Wallets`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetWalletsQueryKey = (params?: GetWalletsParams,) => {
    return [`/Wallets`, ...(params ? [params]: [])] as const;
    }

    
export const getGetWalletsQueryOptions = <TData = Awaited<ReturnType<typeof getWallets>>, TError = unknown>(params?: GetWalletsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallets>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWalletsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWallets>>> = ({ signal }) => getWallets(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWallets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWalletsQueryResult = NonNullable<Awaited<ReturnType<typeof getWallets>>>
export type GetWalletsQueryError = unknown


export function useGetWallets<TData = Awaited<ReturnType<typeof getWallets>>, TError = unknown>(
 params: undefined |  GetWalletsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWallets>>,
          TError,
          Awaited<ReturnType<typeof getWallets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWallets<TData = Awaited<ReturnType<typeof getWallets>>, TError = unknown>(
 params?: GetWalletsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWallets>>,
          TError,
          Awaited<ReturnType<typeof getWallets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWallets<TData = Awaited<ReturnType<typeof getWallets>>, TError = unknown>(
 params?: GetWalletsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallets>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetWallets<TData = Awaited<ReturnType<typeof getWallets>>, TError = unknown>(
 params?: GetWalletsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWallets>>, TError, TData>>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWalletsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const postWallets = (
    walletsBody: WalletsBody,
    params?: PostWalletsParams,
 options?: SecondParameter<typeof customAxios>,signal?: AbortSignal
) => {
      
      
      return customAxios<null>(
      {url: `/Wallets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: walletsBody,
        params, signal
    },
      options);
    }
  


export const getPostWalletsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postWallets>>, TError,{data: WalletsBody;params?: PostWalletsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof postWallets>>, TError,{data: WalletsBody;params?: PostWalletsParams}, TContext> => {

const mutationKey = ['postWallets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postWallets>>, {data: WalletsBody;params?: PostWalletsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postWallets(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostWalletsMutationResult = NonNullable<Awaited<ReturnType<typeof postWallets>>>
    export type PostWalletsMutationBody = WalletsBody
    export type PostWalletsMutationError = unknown

    export const usePostWallets = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postWallets>>, TError,{data: WalletsBody;params?: PostWalletsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postWallets>>,
        TError,
        {data: WalletsBody;params?: PostWalletsParams},
        TContext
      > => {

      const mutationOptions = getPostWalletsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteWallets = (
    params?: DeleteWalletsParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Wallets`, method: 'DELETE',
        params
    },
      options);
    }
  


export const getDeleteWalletsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWallets>>, TError,{params?: DeleteWalletsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteWallets>>, TError,{params?: DeleteWalletsParams}, TContext> => {

const mutationKey = ['deleteWallets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteWallets>>, {params?: DeleteWalletsParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteWallets(params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteWalletsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteWallets>>>
    
    export type DeleteWalletsMutationError = unknown

    export const useDeleteWallets = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteWallets>>, TError,{params?: DeleteWalletsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteWallets>>,
        TError,
        {params?: DeleteWalletsParams},
        TContext
      > => {

      const mutationOptions = getDeleteWalletsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const patchWallets = (
    walletsBody: WalletsBody,
    params?: PatchWalletsParams,
 options?: SecondParameter<typeof customAxios>,) => {
      
      
      return customAxios<null>(
      {url: `/Wallets`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: walletsBody,
        params
    },
      options);
    }
  


export const getPatchWalletsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchWallets>>, TError,{data: WalletsBody;params?: PatchWalletsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
): UseMutationOptions<Awaited<ReturnType<typeof patchWallets>>, TError,{data: WalletsBody;params?: PatchWalletsParams}, TContext> => {

const mutationKey = ['patchWallets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchWallets>>, {data: WalletsBody;params?: PatchWalletsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  patchWallets(data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchWalletsMutationResult = NonNullable<Awaited<ReturnType<typeof patchWallets>>>
    export type PatchWalletsMutationBody = WalletsBody
    export type PatchWalletsMutationError = unknown

    export const usePatchWallets = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchWallets>>, TError,{data: WalletsBody;params?: PatchWalletsParams}, TContext>, request?: SecondParameter<typeof customAxios>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchWallets>>,
        TError,
        {data: WalletsBody;params?: PatchWalletsParams},
        TContext
      > => {

      const mutationOptions = getPatchWalletsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
